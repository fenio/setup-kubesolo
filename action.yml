name: 'Setup KubeSolo'
description: 'Install and configure KubeSolo - Ultra-lightweight single-node Kubernetes for CI/CD'
author: 'fenio'

branding:
  icon: 'box'
  color: 'blue'

inputs:
  version:
    description: 'KubeSolo version to install (e.g., v0.1.7-beta, latest)'
    required: false
    default: 'latest'
  
  wait-for-ready:
    description: 'Wait for KubeSolo cluster to be ready before completing'
    required: false
    default: 'true'
  
  timeout:
    description: 'Timeout in seconds to wait for cluster readiness'
    required: false
    default: '60'

outputs:
  kubeconfig:
    description: 'Path to the kubeconfig file'
    value: ${{ steps.configure.outputs.kubeconfig }}

runs:
  using: 'composite'
  steps:
    - name: Determine KubeSolo version
      id: version
      shell: bash
      env:
        KUBESOLO_VERSION: ${{ inputs.version }}
      run: |
        if [ "${KUBESOLO_VERSION}" = "latest" ]; then
          # Fetch the latest version from GitHub API
          LATEST_VERSION=$(curl -sfL https://api.github.com/repos/portainer/kubesolo/releases/latest | grep -o '"tag_name": *"[^"]*"' | sed 's/"tag_name": *"\(.*\)"/\1/')
          echo "resolved-version=${LATEST_VERSION}" >> $GITHUB_OUTPUT
          echo "Using latest version: ${LATEST_VERSION}"
        else
          echo "resolved-version=${KUBESOLO_VERSION}" >> $GITHUB_OUTPUT
          echo "Using specified version: ${KUBESOLO_VERSION}"
        fi
        
        # Determine architecture for cache key
        ARCH=$(uname -m)
        case $ARCH in
          x86_64) ARCH="amd64" ;;
          aarch64) ARCH="arm64" ;;
          armv7l) ARCH="arm" ;;
        esac
        echo "arch=${ARCH}" >> $GITHUB_OUTPUT
    
    - name: Cache KubeSolo binary
      id: cache
      uses: actions/cache@v4
      with:
        path: ~/.cache/kubesolo
        key: kubesolo-${{ runner.os }}-${{ steps.version.outputs.arch }}-${{ steps.version.outputs.resolved-version }}
    
    - name: Disable conflicting container runtimes
      shell: bash
      run: |
        echo "Disabling conflicting container runtimes..."
        
        # Stop and mask all container runtime services
        sudo systemctl stop docker.socket docker containerd podman 2>/dev/null || true
        sudo systemctl mask docker.socket docker containerd podman 2>/dev/null || true
        
        # Backup runtime binaries to hide them from detection
        for binary in docker dockerd containerd containerd-shim containerd-shim-runc-v2 runc podman; do
          if [ -f "/usr/bin/${binary}" ]; then
            sudo mv "/usr/bin/${binary}" "/usr/bin/${binary}.bak" 2>/dev/null || true
          fi
        done
        
        # Clean up runtime sockets
        sudo rm -rf /var/run/docker* /var/run/containerd /run/containerd /run/docker* 2>/dev/null || true
        
        echo "✓ Container runtime disabled"
    
    - name: Download KubeSolo binary
      if: steps.cache.outputs.cache-hit != 'true'
      shell: bash
      env:
        KUBESOLO_VERSION: ${{ steps.version.outputs.resolved-version }}
        ARCH: ${{ steps.version.outputs.arch }}
      run: |
        echo "Downloading KubeSolo ${KUBESOLO_VERSION}..."
        
        # Detect libc type
        LIBC_SUFFIX=""
        if [ -f /lib/ld-musl-*.so.1 ] || [ -f /usr/lib/ld-musl-*.so.1 ]; then
          if [ "$ARCH" = "amd64" ] || [ "$ARCH" = "arm64" ]; then
            LIBC_SUFFIX="-musl"
          fi
        fi
        
        # Download binary
        mkdir -p ~/.cache/kubesolo
        BIN_URL="https://github.com/portainer/kubesolo/releases/download/${KUBESOLO_VERSION}/kubesolo-${KUBESOLO_VERSION}-linux-${ARCH}${LIBC_SUFFIX}.tar.gz"
        
        echo "Downloading from: ${BIN_URL}"
        curl -sfL "$BIN_URL" -o ~/.cache/kubesolo/kubesolo.tar.gz
        
        # Extract binary
        tar -xzf ~/.cache/kubesolo/kubesolo.tar.gz -C ~/.cache/kubesolo/
        rm ~/.cache/kubesolo/kubesolo.tar.gz
        
        echo "✓ KubeSolo binary downloaded and cached"
    
    - name: Install KubeSolo
      id: install
      shell: bash
      env:
        LOCAL_STORAGE: true
      run: |
        echo "Installing KubeSolo from cache..."
        
        # Install binary
        sudo install -m 755 ~/.cache/kubesolo/kubesolo /usr/local/bin/kubesolo
        
        # Create systemd service
        sudo tee /etc/systemd/system/kubesolo.service > /dev/null <<EOF
        [Unit]
        Description=kubesolo Service
        After=network.target
        
        [Service]
        ExecStart=/usr/local/bin/kubesolo --path=/var/lib/kubesolo --local-storage=true
        Restart=always
        RestartSec=3
        OOMScoreAdjust=-500
        LimitNOFILE=65535
        StandardOutput=journal
        StandardError=journal
        
        [Install]
        WantedBy=multi-user.target
        EOF
        
        # Enable and start service
        sudo systemctl daemon-reload
        sudo systemctl enable kubesolo
        sudo systemctl start kubesolo
        
        echo "✓ KubeSolo installed successfully"
    
    - name: Configure KubeSolo
      id: configure
      shell: bash
      run: |
        # Wait for kubeconfig to be created
        KUBECONFIG_PATH="/var/lib/kubesolo/pki/admin/admin.kubeconfig"
        
        echo "Waiting for KubeSolo to initialize..."
        timeout=60
        elapsed=0
        while [ ! -f "${KUBECONFIG_PATH}" ] && [ $elapsed -lt $timeout ]; do
          if [ $((elapsed % 5)) -eq 0 ]; then
            echo "  Waiting for kubeconfig... (${elapsed}/${timeout}s)"
            # Check service status
            if ! sudo systemctl is-active --quiet kubesolo; then
              echo "  KubeSolo service is not active, checking status:"
              sudo systemctl status kubesolo --no-pager || true
            fi
          fi
          sleep 1
          elapsed=$((elapsed + 1))
        done
        
        if [ ! -f "${KUBECONFIG_PATH}" ]; then
          echo "ERROR: Kubeconfig not found at ${KUBECONFIG_PATH}"
          echo "KubeSolo service status:"
          sudo systemctl status kubesolo --no-pager || true
          echo "KubeSolo logs:"
          sudo journalctl -u kubesolo -n 50 --no-pager || true
          exit 1
        fi
        
        # Make kubeconfig accessible
        sudo chmod 644 "${KUBECONFIG_PATH}"
        
        echo "kubeconfig=${KUBECONFIG_PATH}" >> $GITHUB_OUTPUT
        echo "✓ KubeSolo configured successfully"
    
    - name: Wait for cluster ready
      if: inputs.wait-for-ready == 'true'
      shell: bash
      env:
        TIMEOUT: ${{ inputs.timeout }}
        KUBECONFIG: ${{ steps.configure.outputs.kubeconfig }}
      run: |
        # Use default timeout if not set
        TIMEOUT_SECONDS="${TIMEOUT:-60}"
        echo "Waiting for KubeSolo cluster to be ready (timeout: ${TIMEOUT_SECONDS}s)..."
        
        start_time=$(date +%s)
        while true; do
          current_time=$(date +%s)
          elapsed=$((current_time - start_time))
          
          if [ $elapsed -gt ${TIMEOUT_SECONDS} ]; then
            echo "ERROR: Timeout waiting for cluster to be ready"
            exit 1
          fi
          
          # Check if kubectl can connect to the API server and node is ready
          if kubectl wait --for=condition=Ready nodes --all --timeout=5s &>/dev/null; then
            echo "✓ KubeSolo cluster is ready!"
            kubectl get nodes
            break
          fi
          
          echo "  Cluster not ready yet, waiting... (${elapsed}/${TIMEOUT_SECONDS}s)"
          sleep 5
        done

