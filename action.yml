name: 'Setup KubeSolo'
description: 'Install and configure KubeSolo - Ultra-lightweight single-node Kubernetes for CI/CD'
author: 'fenio'

branding:
  icon: 'box'
  color: 'blue'

inputs:
  version:
    description: 'KubeSolo version to install (e.g., v0.1.7-beta, latest)'
    required: false
    default: 'latest'
  
  wait-for-ready:
    description: 'Wait for KubeSolo cluster to be ready before completing'
    required: false
    default: 'true'
  
  timeout:
    description: 'Timeout in seconds to wait for cluster readiness'
    required: false
    default: '60'

outputs:
  kubeconfig:
    description: 'Path to the kubeconfig file'
    value: ${{ steps.install.outputs.kubeconfig }}
  
  cluster-info:
    description: 'KubeSolo cluster information'
    value: ${{ steps.verify.outputs.cluster-info }}

runs:
  using: 'composite'
  steps:
    - name: Remove conflicting container runtimes
      shell: bash
      run: |
        echo "Removing conflicting container runtimes..."
        
        # Stop all container runtime services
        sudo systemctl stop docker.socket docker containerd podman 2>/dev/null || true
        sudo systemctl disable docker.socket docker containerd podman 2>/dev/null || true
        
        # Remove all container runtime packages
        sudo apt-get remove -y \
          docker docker-engine docker.io docker-ce docker-ce-cli \
          containerd containerd.io runc \
          podman \
          docker-buildx-plugin docker-compose-plugin \
          2>/dev/null || true
        
        sudo apt-get purge -y docker-ce docker-ce-cli containerd.io 2>/dev/null || true
        sudo apt-get autoremove -y 2>/dev/null || true
        
        # Clean up runtime files and sockets
        sudo rm -rf /var/run/docker* /var/run/containerd /run/containerd 2>/dev/null || true
        
        echo "✓ Container runtime cleanup complete"
    
    - name: Install KubeSolo
      id: install
      shell: bash
      env:
        KUBESOLO_VERSION: ${{ inputs.version }}
      run: |
        # Use default version if not set
        KUBESOLO_VERSION="${KUBESOLO_VERSION:-latest}"
        echo "Installing KubeSolo ${KUBESOLO_VERSION}..."
        
        # Install KubeSolo
        if [ "${KUBESOLO_VERSION}" = "latest" ]; then
          # Don't pass version for latest, let installer determine it
          curl -sfL https://get.kubesolo.io | sudo sh -
        else
          curl -sfL https://get.kubesolo.io | INSTALL_KUBESOLO_VERSION="${KUBESOLO_VERSION}" sudo sh -
        fi
        
        # Set kubeconfig path output
        KUBECONFIG_PATH="/var/lib/kubesolo/pki/admin/admin.kubeconfig"
        echo "kubeconfig=${KUBECONFIG_PATH}" >> $GITHUB_OUTPUT
        
        # Make kubeconfig accessible
        sudo chmod 644 "${KUBECONFIG_PATH}"
        
        echo "✓ KubeSolo installed successfully"
    
    - name: Configure kubectl
      shell: bash
      run: |
        echo "Configuring kubectl..."
        
        # Set KUBECONFIG environment variable
        KUBECONFIG_PATH="${{ steps.install.outputs.kubeconfig }}"
        echo "KUBECONFIG=${KUBECONFIG_PATH}" >> $GITHUB_ENV
        
        # Install kubectl if not present
        if ! command -v kubectl &> /dev/null; then
          echo "Installing kubectl..."
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          rm kubectl
        fi
        
        echo "✓ kubectl configured (version: $(kubectl version --client --short 2>/dev/null || kubectl version --client))"
    
    - name: Wait for cluster ready
      if: inputs.wait-for-ready == 'true'
      shell: bash
      env:
        TIMEOUT: ${{ inputs.timeout }}
      run: |
        # Use default timeout if not set
        TIMEOUT_SECONDS="${TIMEOUT:-60}"
        echo "Waiting for KubeSolo cluster to be ready (timeout: ${TIMEOUT_SECONDS}s)..."
        
        export KUBECONFIG="${{ steps.install.outputs.kubeconfig }}"
        
        start_time=$(date +%s)
        while true; do
          current_time=$(date +%s)
          elapsed=$((current_time - start_time))
          
          if [ $elapsed -gt ${TIMEOUT_SECONDS} ]; then
            echo "ERROR: Timeout waiting for cluster to be ready"
            exit 1
          fi
          
          # Check if API server is responding
          if kubectl cluster-info &>/dev/null; then
            echo "  API server is responding"
            
            # Check if node is ready
            if kubectl wait --for=condition=Ready nodes --all --timeout=10s &>/dev/null; then
              echo "  Node is ready"
              break
            fi
          fi
          
          echo "  Cluster not ready yet, waiting... (${elapsed}/${TIMEOUT_SECONDS}s)"
          sleep 5
        done
        
        echo "✓ KubeSolo cluster is ready!"
    
    - name: Verify installation
      id: verify
      shell: bash
      run: |
        echo "Verifying KubeSolo installation..."
        
        export KUBECONFIG="${{ steps.install.outputs.kubeconfig }}"
        
        echo ""
        echo "Cluster Info:"
        kubectl cluster-info
        
        echo ""
        echo "Node Status:"
        kubectl get nodes -o wide
        
        echo ""
        echo "System Pods:"
        kubectl get pods -A
        
        echo ""
        echo "Kubernetes Version:"
        kubectl version --short 2>/dev/null || kubectl version
        
        # Save cluster info to output
        CLUSTER_INFO=$(kubectl cluster-info 2>&1 | head -n 1)
        echo "cluster-info=${CLUSTER_INFO}" >> $GITHUB_OUTPUT
        
        echo ""
        echo "✓ All checks passed!"
