name: 'Setup KubeSolo'
description: 'Install and configure KubeSolo - Ultra-lightweight single-node Kubernetes for CI/CD'
author: 'fenio'

branding:
  icon: 'box'
  color: 'blue'

inputs:
  version:
    description: 'KubeSolo version to install (e.g., v0.1.7-beta, latest)'
    required: false
    default: 'latest'
  
  kubesolo-path:
    description: 'Path to the directory containing KubeSolo configuration files'
    required: false
    default: '/var/lib/kubesolo'
  
  apiserver-extra-sans:
    description: 'Comma-separated list of additional SANs for API server TLS certificate (e.g., 10.0.0.4,kubesolo.local)'
    required: false
    default: ''
  
  local-storage:
    description: 'Enable local storage'
    required: false
    default: 'true'
  
  portainer-edge-id:
    description: 'Portainer Edge ID for edge agent integration'
    required: false
    default: ''
  
  portainer-edge-key:
    description: 'Portainer Edge Key for edge agent integration'
    required: false
    default: ''
  
  portainer-edge-async:
    description: 'Enable Portainer Edge Async Mode'
    required: false
    default: 'false'
  
  wait-for-ready:
    description: 'Wait for KubeSolo cluster to be ready before completing'
    required: false
    default: 'true'
  
  timeout:
    description: 'Timeout in seconds to wait for cluster readiness'
    required: false
    default: '300'

outputs:
  kubeconfig:
    description: 'Path to the kubeconfig file'
    value: ${{ steps.install.outputs.kubeconfig }}
  
  cluster-info:
    description: 'KubeSolo cluster information'
    value: ${{ steps.verify.outputs.cluster-info }}

runs:
  using: 'composite'
  steps:
    - name: Remove conflicting container runtimes
      shell: bash
      run: |
        echo "::group::Removing conflicting container runtimes"
        
        # Stop and remove Docker
        if command -v docker &> /dev/null || systemctl list-unit-files | grep -q docker; then
          echo "Docker detected, removing it..."
          
          # Stop Docker services
          sudo systemctl stop docker.socket 2>/dev/null || true
          sudo systemctl stop docker 2>/dev/null || true
          
          # Remove Docker packages
          sudo apt-get remove -y docker docker-engine docker.io containerd runc docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 2>/dev/null || true
          sudo apt-get purge -y docker-ce docker-ce-cli containerd.io 2>/dev/null || true
          
          echo "✓ Docker removed"
        fi
        
        # Stop and remove Podman
        if command -v podman &> /dev/null; then
          echo "Podman detected, removing it..."
          sudo systemctl stop podman 2>/dev/null || true
          sudo apt-get remove -y podman 2>/dev/null || true
          echo "✓ Podman removed"
        fi
        
        # Clean up
        sudo apt-get autoremove -y 2>/dev/null || true
        
        echo "Container runtime cleanup complete"
        echo "::endgroup::"
    
    - name: Install KubeSolo
      id: install
      shell: bash
      env:
        KUBESOLO_VERSION: ${{ inputs.version }}
        KUBESOLO_PATH: ${{ inputs.kubesolo-path }}
        KUBESOLO_APISERVER_EXTRA_SANS: ${{ inputs.apiserver-extra-sans }}
        KUBESOLO_LOCAL_STORAGE: ${{ inputs.local-storage }}
        KUBESOLO_PORTAINER_EDGE_ID: ${{ inputs.portainer-edge-id }}
        KUBESOLO_PORTAINER_EDGE_KEY: ${{ inputs.portainer-edge-key }}
        KUBESOLO_PORTAINER_EDGE_ASYNC: ${{ inputs.portainer-edge-async }}
      run: |
        echo "::group::Installing KubeSolo"
        
        # Build environment variables for installer
        export KUBESOLO_PATH="${KUBESOLO_PATH}"
        
        if [ -n "${KUBESOLO_APISERVER_EXTRA_SANS}" ]; then
          export KUBESOLO_APISERVER_EXTRA_SANS="${KUBESOLO_APISERVER_EXTRA_SANS}"
        fi
        
        if [ -n "${KUBESOLO_LOCAL_STORAGE}" ]; then
          export KUBESOLO_LOCAL_STORAGE="${KUBESOLO_LOCAL_STORAGE}"
        fi
        
        if [ -n "${KUBESOLO_PORTAINER_EDGE_ID}" ]; then
          export KUBESOLO_PORTAINER_EDGE_ID="${KUBESOLO_PORTAINER_EDGE_ID}"
        fi
        
        if [ -n "${KUBESOLO_PORTAINER_EDGE_KEY}" ]; then
          export KUBESOLO_PORTAINER_EDGE_KEY="${KUBESOLO_PORTAINER_EDGE_KEY}"
        fi
        
        if [ -n "${KUBESOLO_PORTAINER_EDGE_ASYNC}" ]; then
          export KUBESOLO_PORTAINER_EDGE_ASYNC="${KUBESOLO_PORTAINER_EDGE_ASYNC}"
        fi
        
        # Install KubeSolo
        if [ "${KUBESOLO_VERSION}" = "latest" ]; then
          curl -sfL https://get.kubesolo.io | sudo -E sh -
        else
          curl -sfL https://get.kubesolo.io | INSTALL_KUBESOLO_VERSION="${KUBESOLO_VERSION}" sudo -E sh -
        fi
        
        # Set kubeconfig path output
        KUBECONFIG_PATH="${KUBESOLO_PATH}/pki/admin/admin.kubeconfig"
        echo "kubeconfig=${KUBECONFIG_PATH}" >> $GITHUB_OUTPUT
        
        # Make kubeconfig accessible
        sudo chmod 644 "${KUBECONFIG_PATH}"
        
        echo "::endgroup::"
    
    - name: Configure kubectl
      shell: bash
      run: |
        echo "::group::Configuring kubectl"
        
        # Set KUBECONFIG environment variable
        KUBECONFIG_PATH="${{ steps.install.outputs.kubeconfig }}"
        echo "KUBECONFIG=${KUBECONFIG_PATH}" >> $GITHUB_ENV
        
        # Install kubectl if not present
        if ! command -v kubectl &> /dev/null; then
          echo "Installing kubectl..."
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          rm kubectl
        fi
        
        echo "kubectl version: $(kubectl version --client --short 2>/dev/null || kubectl version --client)"
        echo "::endgroup::"
    
    - name: Wait for cluster ready
      if: inputs.wait-for-ready == 'true'
      shell: bash
      env:
        TIMEOUT: ${{ inputs.timeout }}
      run: |
        echo "::group::Waiting for cluster to be ready"
        
        export KUBECONFIG="${{ steps.install.outputs.kubeconfig }}"
        
        echo "Waiting for KubeSolo cluster to be ready (timeout: ${TIMEOUT}s)..."
        
        start_time=$(date +%s)
        while true; do
          current_time=$(date +%s)
          elapsed=$((current_time - start_time))
          
          if [ $elapsed -gt ${TIMEOUT} ]; then
            echo "::error::Timeout waiting for cluster to be ready"
            exit 1
          fi
          
          # Check if API server is responding
          if kubectl cluster-info &>/dev/null; then
            echo "API server is responding"
            
            # Check if node is ready
            if kubectl wait --for=condition=Ready nodes --all --timeout=10s &>/dev/null; then
              echo "Node is ready"
              break
            fi
          fi
          
          echo "Cluster not ready yet, waiting... (${elapsed}/${TIMEOUT}s)"
          sleep 5
        done
        
        echo "KubeSolo cluster is ready!"
        echo "::endgroup::"
    
    - name: Verify installation
      id: verify
      shell: bash
      run: |
        echo "::group::Verifying KubeSolo installation"
        
        export KUBECONFIG="${{ steps.install.outputs.kubeconfig }}"
        
        echo "Cluster Info:"
        kubectl cluster-info
        
        echo ""
        echo "Node Status:"
        kubectl get nodes -o wide
        
        echo ""
        echo "System Pods:"
        kubectl get pods -A
        
        echo ""
        echo "Kubernetes Version:"
        kubectl version --short 2>/dev/null || kubectl version
        
        # Save cluster info to output
        CLUSTER_INFO=$(kubectl cluster-info 2>&1 | head -n 1)
        echo "cluster-info=${CLUSTER_INFO}" >> $GITHUB_OUTPUT
        
        echo "::endgroup::"
