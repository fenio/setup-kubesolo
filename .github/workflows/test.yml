name: Test Setup KubeSolo Action

on:
  push:
    branches:
      - main
  pull_request:
  workflow_dispatch:

jobs:
  test-basic-setup:
    runs-on: ubuntu-latest
    name: Basic KubeSolo Setup
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup KubeSolo
        id: kubesolo
        uses: ./
      
      - name: Verify cluster
        run: |
          echo "Kubeconfig: ${{ steps.kubesolo.outputs.kubeconfig }}"
          echo "Cluster Info: ${{ steps.kubesolo.outputs.cluster-info }}"
          
          kubectl cluster-info
          kubectl get nodes
          kubectl get pods -A
      
      - name: Test deployment
        run: |
          kubectl create deployment nginx --image=nginx:alpine
          kubectl wait --for=condition=available --timeout=120s deployment/nginx
          kubectl get deployments
          kubectl delete deployment nginx

  test-custom-config:
    runs-on: ubuntu-latest
    name: Custom Configuration
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup KubeSolo with custom config
        uses: ./
        with:
          version: 'latest'
          apiserver-extra-sans: 'test.local,10.0.0.1'
          timeout: '600'
      
      - name: Verify custom configuration
        run: |
          kubectl get nodes -o wide
          kubectl get pods -A

  test-workload-deployment:
    runs-on: ubuntu-latest
    name: Deploy Sample Workload
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup KubeSolo
        uses: ./
      
      - name: Create test namespace
        run: kubectl create namespace test-app
      
      - name: Deploy sample application
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: hello-world
            namespace: test-app
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: hello-world
            template:
              metadata:
                labels:
                  app: hello-world
              spec:
                containers:
                - name: hello-world
                  image: gcr.io/google-samples/hello-app:1.0
                  ports:
                  - containerPort: 8080
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: hello-world
            namespace: test-app
          spec:
            type: NodePort
            selector:
              app: hello-world
            ports:
            - port: 8080
              targetPort: 8080
          EOF
      
      - name: Wait for deployment
        run: |
          kubectl wait --for=condition=available --timeout=120s deployment/hello-world -n test-app
          kubectl get all -n test-app
      
      - name: Test service
        run: |
          kubectl get svc -n test-app
          kubectl describe svc hello-world -n test-app
      
      - name: Cleanup
        run: kubectl delete namespace test-app

  test-helm-integration:
    runs-on: ubuntu-latest
    name: Helm Integration Test
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup KubeSolo
        uses: ./
      
      - name: Install Helm
        uses: azure/setup-helm@v4
      
      - name: Add Helm repository
        run: |
          helm repo add bitnami https://charts.bitnami.com/bitnami
          helm repo update
      
      - name: Install chart
        run: |
          helm install my-nginx bitnami/nginx --set service.type=NodePort
          kubectl wait --for=condition=available --timeout=120s deployment/my-nginx
      
      - name: Verify installation
        run: |
          helm list
          kubectl get all
      
      - name: Cleanup
        run: helm uninstall my-nginx

  test-kubectl-operations:
    runs-on: ubuntu-latest
    name: kubectl Operations Test
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup KubeSolo
        uses: ./
      
      - name: Test various kubectl commands
        run: |
          # Create resources
          kubectl create namespace test-ops
          kubectl create configmap test-config --from-literal=key=value -n test-ops
          kubectl create secret generic test-secret --from-literal=password=secret -n test-ops
          
          # List resources
          kubectl get namespaces
          kubectl get configmaps -n test-ops
          kubectl get secrets -n test-ops
          
          # Describe resources
          kubectl describe namespace test-ops
          
          # Test resource quotas
          kubectl create quota test-quota --hard=cpu=1,memory=1G,pods=10 -n test-ops
          kubectl describe quota test-quota -n test-ops
          
          # Cleanup
          kubectl delete namespace test-ops

  test-storage:
    runs-on: ubuntu-latest
    name: Test Local Storage
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup KubeSolo
        uses: ./
        with:
          local-storage: 'true'
      
      - name: Check storage class availability
        run: |
          echo "Checking for storage classes..."
          kubectl get storageclass || echo "No storage classes found"
          
          # Check if local-path-provisioner is installed
          kubectl get pods -n kube-system | grep -i storage || echo "No storage provisioner pods found"
          kubectl get pods -n kube-system | grep -i local-path || echo "No local-path-provisioner found"
          
          # List all deployments in kube-system to see what's available
          echo "All kube-system deployments:"
          kubectl get deployments -n kube-system
      
      - name: Test emptyDir volume
        run: |
          echo "Testing emptyDir volume..."
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Pod
          metadata:
            name: test-emptydir-pod
          spec:
            containers:
            - name: test
              image: busybox
              command: ['sh', '-c', 'echo "Hello from emptyDir" > /data/test.txt && cat /data/test.txt && sleep 10']
              volumeMounts:
              - name: storage
                mountPath: /data
            volumes:
            - name: storage
              emptyDir: {}
          EOF
          
          kubectl wait --for=condition=Ready --timeout=60s pod/test-emptydir-pod
          kubectl logs test-emptydir-pod
          kubectl delete pod test-emptydir-pod
          echo "✓ emptyDir volume works"
      
      - name: Test hostPath volume
        run: |
          echo "Testing hostPath volume..."
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Pod
          metadata:
            name: test-hostpath-pod
          spec:
            containers:
            - name: test
              image: busybox
              command: ['sh', '-c', 'echo "Hello from hostPath" > /data/test.txt && cat /data/test.txt && ls -la /data && sleep 10']
              volumeMounts:
              - name: storage
                mountPath: /data
            volumes:
            - name: storage
              hostPath:
                path: /tmp/kubesolo-test
                type: DirectoryOrCreate
          EOF
          
          kubectl wait --for=condition=Ready --timeout=60s pod/test-hostpath-pod
          kubectl logs test-hostpath-pod
          kubectl delete pod test-hostpath-pod
          echo "✓ hostPath volume works"
      
      - name: Test storage class based PVC (if available)
        run: |
          # Only run this if a storage class exists
          if kubectl get storageclass 2>/dev/null | grep -q NAME; then
            echo "Storage class found, testing PVC..."
            STORAGE_CLASS=$(kubectl get storageclass -o jsonpath='{.items[0].metadata.name}')
            echo "Using storage class: ${STORAGE_CLASS}"
            
            cat <<EOF | kubectl apply -f -
            apiVersion: v1
            kind: PersistentVolumeClaim
            metadata:
              name: test-pvc
            spec:
              storageClassName: ${STORAGE_CLASS}
              accessModes:
                - ReadWriteOnce
              resources:
                requests:
                  storage: 1Gi
          EOF
            
            echo "Waiting for PVC to be bound..."
            if kubectl wait --for=jsonpath='{.status.phase}'=Bound --timeout=60s pvc/test-pvc; then
              echo "PVC bound successfully, testing with pod..."
              
              cat <<EOF | kubectl apply -f -
              apiVersion: v1
              kind: Pod
              metadata:
                name: test-pvc-pod
              spec:
                containers:
                - name: test
                  image: busybox
                  command: ['sh', '-c', 'echo "Hello from PVC" > /data/test.txt && cat /data/test.txt && sleep 10']
                  volumeMounts:
                  - name: storage
                    mountPath: /data
                volumes:
                - name: storage
                  persistentVolumeClaim:
                    claimName: test-pvc
          EOF
              
              kubectl wait --for=condition=Ready --timeout=60s pod/test-pvc-pod
              kubectl logs test-pvc-pod
              kubectl delete pod test-pvc-pod
              kubectl delete pvc test-pvc
              echo "✓ PVC storage works"
            else
              echo "PVC did not bind, skipping pod test"
              kubectl describe pvc test-pvc
              kubectl delete pvc test-pvc
            fi
          else
            echo "No storage class available, skipping PVC test"
            echo "Note: KubeSolo local-storage option does not automatically provision a storage class"
          fi
